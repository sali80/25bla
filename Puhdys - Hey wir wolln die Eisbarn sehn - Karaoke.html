<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karaoke</title>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif; /* Eine gut lesbare Schriftart */
            font-size: 2.5em; /* Große Schrift */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Mindesthöhe des Viewports */
            margin: 0;
            overflow: hidden; /* Verhindert Scrollbalken, falls Text überläuft */
        }

        #karaoke-display {
            text-align: center;
            padding: 20px;
            max-width: 80%; /* Begrenzt die Breite des Textblocks */
        }

        #karaoke-display p {
            margin: 0.5em 0; /* Abstand zwischen den Zeilen */
            opacity: 0.7; /* Normale Zeilen etwas weniger prominent */
            transition: opacity 0.3s ease-in-out; /* Sanfter Übergang beim Ändern der Opazität */
        }

        #karaoke-display p.bold-line {
            font-weight: bold;
            font-size: 1.2em; /* Die fette Zeile noch etwas größer */
            opacity: 1; /* Die fette Zeile ist voll sichtbar */
        }
    </style>
</head>
<body>
    <div id="karaoke-display">
        <!-- Der Text wird hier von JavaScript eingefügt -->
    </div>

    <!-- Das Audio-Element für die Musik -->
    <audio id="karaoke-audio" src="Puhdys%20-%20Hey%20wir%20wolln%20die%20Eisbarn%20sehn%20-%20Karaoke.mp3" preload="auto"></audio>

    <script>
        // +++ Audio-bezogene Variablen und Funktionen +++
        const karaokeAudio = document.getElementById('karaoke-audio');
        let audioStarted = false; // Flag, um zu prüfen, ob Audio bereits gestartet wurde

        function startAudio() {
            if (!audioStarted && karaokeAudio) {
                karaokeAudio.play().catch(e => {
                    console.error("Fehler beim Abspielen der Audiodatei:", e);
                    // Hier könntest du eine Meldung an den Benutzer anzeigen,
                    // falls die automatische Wiedergabe blockiert wurde.
                });
                audioStarted = true;
                // Sobald die Musik erfolgreich gestartet wurde, aktivieren wir den timeupdate-Listener
                karaokeAudio.addEventListener('timeupdate', handleTimeUpdate);
            }
        }

        function stopAudio() {
            if (karaokeAudio && !karaokeAudio.paused) {
                karaokeAudio.pause();
                karaokeAudio.currentTime = 0; // Setzt die Wiedergabe auf den Anfang zurück
                audioStarted = false; // Setzt das Flag zurück, falls man neu starten möchte
                karaokeAudio.removeEventListener('timeupdate', handleTimeUpdate); // Listener entfernen
            }
        }
        // +++ Ende Audio-bezogene Variablen und Funktionen +++

        // Raw text data with timestamps
        const rawTextData = [
	"[00:00.00],\"WIR WOLLN DIE EISBÄRN SEHN\"",
	"[00:23.00],\"+++\"",
	"[00:28.16],\"Im Werk weht nun ein anderer Wind,\"",
	"[00:35.73],\"Tickets einstelln kann doch je-edes Kind\"",
	"[00:43.83],\"Für je-den Klick, für je-den Mist,\"",
	"[00:51.71],\"gibt’s jetzt ’nen Ticket, was Scheiße ist.\"",
	"[00:56.30],\"+++\"",
	"[00:59.34],\"Heeeey - wir woll’n die Tickets seh´n! ohohohohoh\"",
	"[01:07.11],\"In HR wird sonst gar nix gehn. ohohohohoh\"",
	"[01:15.34],\"Sie sam-meln sich, wer-den nicht sor-tiert -\"",
	"[01:21.27],\"lie-gen wochen-lang, unbe-rührt.\"",
	"[01:25.30],\"lie-gen wochen-lang, unbe-rührt.\"",
	"[01:28.18],\"+++\"",
	"[01:41.89],\"In HR sitzt Uwe auf seinem Thron,\"",
	"[01:49.59],\"die GL rennt von den Tickets davon\"",
	"[01:57.56],\"Für je-den Mist, für je-den Klick,\"",
	"[02:05.42],\"gibt’s jetzt ’nen Workflow, den kei-ner blickt.\"",
	"[02:10.19],\"+++\"",
	"[02:13.18],\"Heeey - ihr stellt sie trotz-dem ein, ohohohohoh\"",
	"[02:20.90],\"für unsern Bür-o-kratieverein. ohohohohoh\"",
	"[02:28.74],\"Sie sam-meln sich, wer-den nicht sor-tiert -\"",
	"[02:35.23],\"Und dann geschlossen, unbe-rührt.\"",
	"[02:38.95],\"Und dann geschlossen, unbe-rührt.\"",
	"[02:41.88],\"+++\"",
	"[02:59.40],\"Heeey - ihr stellt sie trotz-dem ein, ohohohohoh\"",
	"[03:07.30],\"für unsern Bür-o-kratieverein. ohohohohoh\"",
	"[03:15.37],\"Sie sam-meln sich, wer-den nicht sor-tiert -\"",
	"[03:20.85],\"Und dann geschlossen, unbe-rührt.\"",
	"[03:25.20],\"Und dann geschlossen, unbe-rührt.\"",
	"[03:28.19],\"+++\"",
	"[03:29.68],\"Ohohohohoh\"",
	"[03:33.61],\"Ohohohohoh\"",
	"[03:36.77],\"Wir wolln die Tickets sehn\"",
	"[03:37.61],\"Ohohohohoh\"",
	"[03:40.19],\"Wir wolln die Tickets sehn\"",
	"[03:41.65],\"Ohohohohoh\"",
	"[03:44.11],\"Wir wolln die Tickets sehn\"",
	"[03:45.57],\"Ohohohohoh\"",
	"[03:47.90],\"Wir wolln die Tickets sehn\"",
	"[03:49.66],\"Ohohohohoh\"",
	"[03:50.99],\"+++\""
        ];

        // Parse the raw text data into an array of objects { timestamp: ms, text: string }
        const textLines = rawTextData.map(line => {
            const parts = line.match(/^\[(\d{2}):(\d{2})\.(\d{2})\],"(.*)"$/);
            if (!parts) {
                console.error("Fehler beim Parsen der Zeile:", line);
                return null;
            }
            const minutes = parseInt(parts[1], 10);
            const seconds = parseInt(parts[2], 10);
            const centiseconds = parseInt(parts[3], 10); // .00 are centiseconds
            const totalMilliseconds = (minutes * 60 * 1000) + (seconds * 1000) + (centiseconds * 10); // *10 for ms
            const text = parts[4];
            return { timestamp: totalMilliseconds, text: text };
        }).filter(Boolean); // Remove any null entries from parsing errors

        let currentLineIndex = 0; // Dieser Index zeigt auf die Zeile, deren Zeitstempel gerade erreicht wurde
        const displayContainer = document.getElementById('karaoke-display');

        function updateDisplay() {
            displayContainer.innerHTML = ''; // Alten Inhalt löschen

            if (currentLineIndex >= textLines.length) {
                // Alle Zeilen verarbeitet, Anzeige leeren und Audio stoppen
                displayContainer.innerHTML = '';
                stopAudio();
                return;
            }

            // Finde die tatsächliche Zeile, die fett angezeigt werden soll.
            // Dies ist die erste nicht-Bindestrich-Zeile ab currentLineIndex.
            let boldLineToDisplayIndex = currentLineIndex;
            while (boldLineToDisplayIndex < textLines.length && textLines[boldLineToDisplayIndex].text.trim() === '-') {
                boldLineToDisplayIndex++;
            }

            // Wenn ab currentLineIndex nur noch Bindestrich-Zeilen oder das Ende erreicht ist
            if (boldLineToDisplayIndex >= textLines.length) {
                displayContainer.innerHTML = ''; // Anzeige leeren
                stopAudio();
                return;
            }

            // Die aktuelle (fette) Zeile anzeigen
            const boldLine = document.createElement('p');
            boldLine.classList.add('bold-line');
            boldLine.textContent = textLines[boldLineToDisplayIndex].text;
            displayContainer.appendChild(boldLine);

            // Die nächsten drei normalen Zeilen anzeigen, beginnend direkt nach der fettgedruckten Zeile
            let normalLinesCount = 0;
            for (let i = boldLineToDisplayIndex + 1; i < textLines.length && normalLinesCount < 3; i++) {
                const normalLine = document.createElement('p');
                normalLine.textContent = textLines[i].text;
                displayContainer.appendChild(normalLine);
                normalLinesCount++;
            }
        }

        // Funktion zur Handhabung der automatischen Zeilenaktualisierung basierend auf der Audiozeit
        function handleTimeUpdate() {
            const currentTimeMs = karaokeAudio.currentTime * 1000;

            // Finde den Index der nächsten Zeile, deren Zeitstempel erreicht oder überschritten wurde
            let nextLineIndex = currentLineIndex;
            while (nextLineIndex < textLines.length - 1 && currentTimeMs >= textLines[nextLineIndex + 1].timestamp) {
                nextLineIndex++;
            }

            // Wenn sich der aktuelle Zeilenindex geändert hat, aktualisiere die Anzeige
            if (nextLineIndex !== currentLineIndex) {
                currentLineIndex = nextLineIndex;
                updateDisplay();
            }

            // Wenn wir die letzte Zeile überschritten haben und die Musik noch läuft,
            // stellen wir sicher, dass die Anzeige geleert und die Musik gestoppt wird.
            // Füge einen kleinen Puffer hinzu, falls die letzte Zeile sehr kurz ist.
            // Hier 5 Sekunden Puffer nach dem Zeitstempel der letzten Zeile.
            if (currentLineIndex >= textLines.length - 1 && currentTimeMs >= textLines[textLines.length - 1].timestamp + 5000) {
                if (displayContainer.innerHTML !== '') { // Nur leeren, wenn nicht schon leer
                    displayContainer.innerHTML = '';
                    stopAudio();
                }
            }
        }

        // Event-Listener für die erste Benutzerinteraktion (z.B. beliebiger Tastendruck)
        document.addEventListener('keydown', () => {
            startAudio(); // Startet die Musik und aktiviert den timeupdate-Listener
        });

        // Initialer Aufruf, um den ersten Text anzuzeigen, wenn die Seite geladen wird (bevor die Musik startet)
        updateDisplay();
    </script>
</body>
</html>